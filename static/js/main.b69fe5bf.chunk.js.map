{"version":3,"sources":["util.ts","ColourPicker/ColourPicker.tsx","Interval/Interval.tsx","Form/Form.tsx","App.tsx","serviceWorker.ts","index.tsx"],"names":["formatToRGBString","colour","r","g","b","ColourPicker","ref","handler","id","label","index","onColourChange","popover","useRef","useState","isOpen","setIsOpen","toggle","useCallback","currentValue","useEffect","startedInside","startedWhenMounted","listener","event","current","contains","target","validateEventStart","document","addEventListener","removeEventListener","handleColourChange","className","htmlFor","type","style","backgroundColor","onClick","color","onChange","Interval","firstColour","lastColour","onDurationChange","onDelete","showDeleteButton","hoursInput","minutesInput","secondsInput","handleDurationChange","hours","valueAsNumber","minutes","seconds","handleDeleteInterval","placeholder","min","Form","start","intervals","setIntervals","setTotalDuration","duration","updatedIntervals","updatedInterval","reduce","total","interval","length","handleNewInterval","newIntervals","previousInterval","newInterval","indexOf","TinyColor","tetrad","darken","triad","lighten","push","splice","action","onSubmit","map","defaultIntervals","App","isActive","setIsActive","startDate","setStartDate","currentDate","setCurrentDate","totalDuration","setIndex","currentColour","timer","i","a","Promise","resolve","reject","updatedStartDate","Date","intervalID","setInterval","updatedCurrentDate","getTime","undefined","clearInterval","loopThroughEachInterval","preventDefault","Error","err","console","error","message","timeSpentRatio","changeAmount","Math","round","backgroundImage","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.b69fe5bf.chunk.js","sourcesContent":["import { RgbColor } from \"react-colorful\";\nimport { RefObject, useEffect } from \"react\";\n\nexport const formatToRGBString = (colour: RgbColor): string => {\n  return `rgb(${colour.r}, ${colour.g}, ${colour.b})`;\n};\n\n// Improved version of https://usehooks.com/useOnClickOutside/\nexport const useClickOutside = <Element extends HTMLElement>(\n  ref: RefObject<Element>,\n  handler: EventListener\n) => {\n  useEffect(() => {\n    let startedInside = false;\n    let startedWhenMounted = false;\n\n    const listener: EventListener = (event) => {\n      // Do nothing if `mousedown` or `touchstart` started inside ref element\n      if (startedInside || !startedWhenMounted) return;\n      // Do nothing if clicking ref's element or descendent elements\n      if (!ref.current || ref.current.contains(event.target as Node)) return;\n\n      handler(event);\n    };\n\n    const validateEventStart: EventListener = (event) => {\n      startedWhenMounted = !!ref.current;\n      startedInside =\n        !!ref.current && ref.current.contains(event.target as Node);\n    };\n\n    document.addEventListener(\"mousedown\", validateEventStart);\n    document.addEventListener(\"touchstart\", validateEventStart);\n    document.addEventListener(\"click\", listener);\n\n    return () => {\n      document.removeEventListener(\"mousedown\", validateEventStart);\n      document.removeEventListener(\"touchstart\", validateEventStart);\n      document.removeEventListener(\"click\", listener);\n    };\n  }, [ref, handler]);\n};\n","import React, { useCallback, useRef, useState } from \"react\";\nimport { RgbColorPicker, RgbColor } from \"react-colorful\";\nimport { formatToRGBString, useClickOutside } from \"../util\";\nimport \"./ColourPicker.css\";\n\ntype Props = {\n  id: string;\n  label: string;\n  index: number;\n  colour: RgbColor;\n  onColourChange: (index: number, id: string, colour: RgbColor) => void;\n};\n\nfunction ColourPicker({ id, label, index, colour, onColourChange }: Props) {\n  const popover = useRef<HTMLDivElement>(null);\n  const [isOpen, setIsOpen] = useState(false);\n\n  const toggle = useCallback(() => {\n    setIsOpen((currentValue) => !currentValue);\n  }, []);\n\n  useClickOutside(popover, toggle);\n\n  const handleColourChange = useCallback(\n    (colour: RgbColor) => {\n      onColourChange(index, id, colour);\n    },\n    [index, id, onColourChange]\n  );\n\n  return (\n    <div className=\"picker-container\">\n      <label htmlFor={id}>\n        {label}\n        <button\n          type=\"button\"\n          style={{ backgroundColor: formatToRGBString(colour) }}\n          onClick={toggle}\n        ></button>\n      </label>\n      {isOpen && (\n        <div className=\"picker\" ref={popover}>\n          <RgbColorPicker color={colour} onChange={handleColourChange} />\n        </div>\n      )}\n    </div>\n  );\n}\n\nexport default ColourPicker;\n","import React, { useRef, useCallback } from \"react\";\r\nimport ColourPicker from \"../ColourPicker/ColourPicker\";\r\nimport { RgbColor } from \"react-colorful\";\r\nimport \"./Interval.css\";\r\n\r\ntype Props = {\r\n  index: number;\r\n  firstColour: RgbColor;\r\n  lastColour: RgbColor;\r\n  onDurationChange: (index: number, duration: number) => void;\r\n  onColourChange: (index: number, id: string, colour: RgbColor) => void;\r\n  onDelete: (index: number) => void;\r\n  showDeleteButton: boolean;\r\n};\r\n\r\nconst Interval = ({\r\n  index,\r\n  firstColour,\r\n  lastColour,\r\n  onDurationChange,\r\n  onColourChange,\r\n  onDelete,\r\n  showDeleteButton,\r\n}: Props) => {\r\n  const hoursInput = useRef<HTMLInputElement>(null);\r\n  const minutesInput = useRef<HTMLInputElement>(null);\r\n  const secondsInput = useRef<HTMLInputElement>(null);\r\n\r\n  const handleDurationChange = useCallback(() => {\r\n    const hours: number = hoursInput.current?.valueAsNumber || 0;\r\n    const minutes: number = minutesInput.current?.valueAsNumber || 0;\r\n    const seconds: number = secondsInput.current?.valueAsNumber || 0;\r\n    const duration: number = (hours * 3600 + minutes * 60 + seconds) * 1000;\r\n\r\n    onDurationChange(index, duration);\r\n  }, [index, onDurationChange]);\r\n\r\n  const handleDeleteInterval = useCallback(() => {\r\n    onDelete(index);\r\n  }, [index, onDelete]);\r\n\r\n  return (\r\n    <div className=\"interval\">\r\n      <div id=\"duration\">\r\n        <label htmlFor=\"hours\">H</label>\r\n        <input\r\n          id=\"hours\"\r\n          type=\"number\"\r\n          placeholder=\"0\"\r\n          min=\"0\"\r\n          ref={hoursInput}\r\n          onChange={handleDurationChange}\r\n        />\r\n\r\n        <label htmlFor=\"minutes\">M</label>\r\n        <input\r\n          id=\"minutes\"\r\n          type=\"number\"\r\n          placeholder=\"0\"\r\n          min=\"0\"\r\n          ref={minutesInput}\r\n          onChange={handleDurationChange}\r\n        />\r\n\r\n        <label htmlFor=\"seconds\">S</label>\r\n        <input\r\n          id=\"seconds\"\r\n          type=\"number\"\r\n          placeholder=\"0\"\r\n          min=\"0\"\r\n          ref={secondsInput}\r\n          onChange={handleDurationChange}\r\n        />\r\n      </div>\r\n      <ColourPicker\r\n        id=\"firstColour\"\r\n        label=\"First Colour\"\r\n        index={index}\r\n        colour={firstColour}\r\n        onColourChange={onColourChange}\r\n      />\r\n      <ColourPicker\r\n        id=\"lastColour\"\r\n        label=\"Last Colour\"\r\n        index={index}\r\n        colour={lastColour}\r\n        onColourChange={onColourChange}\r\n      />\r\n      {showDeleteButton && (\r\n        <button\r\n          type=\"button\"\r\n          className=\"delete-button\"\r\n          onClick={handleDeleteInterval}\r\n        >\r\n          X\r\n        </button>\r\n      )}\r\n    </div>\r\n  );\r\n};\r\n\r\nexport default Interval;\r\n","import React, { FormEvent, useCallback } from \"react\";\nimport Interval from \"../Interval/Interval\";\nimport { TInterval } from \"../App\";\nimport \"./Form.css\";\nimport { RgbColor } from \"react-colorful\";\nimport { TinyColor, random } from \"@ctrl/tinycolor\";\n\ntype Props = {\n  start: (event: FormEvent) => void;\n  intervals: TInterval[];\n  setIntervals: (intervals: TInterval[]) => void;\n  setTotalDuration: (duration: number) => void;\n};\n\nfunction Form({ start, intervals, setIntervals, setTotalDuration }: Props) {\n  const handleDurationChange = useCallback(\n    (index: number, duration: number) => {\n      const updatedIntervals = [...intervals];\n      const updatedInterval = {\n        ...updatedIntervals[index],\n        duration: duration,\n      };\n      updatedIntervals[index] = updatedInterval;\n\n      setTotalDuration(\n        updatedIntervals.reduce((total, interval) => {\n          return total + interval.duration;\n        }, 0)\n      );\n      setIntervals(updatedIntervals);\n    },\n    [intervals, setIntervals, setTotalDuration]\n  );\n\n  const handleColourChange = useCallback(\n    (index: number, id: string, colour: RgbColor) => {\n      const updatedIntervals = [...intervals];\n      const updatedInterval = { ...updatedIntervals[index], [id]: colour };\n      updatedIntervals[index] = updatedInterval;\n      if (intervals.length > 1 && id === \"firstColour\" && index > 0) {\n        updatedIntervals[index - 1] = {\n          ...updatedIntervals[index - 1],\n          lastColour: colour,\n        };\n      }\n      if (\n        intervals.length > 1 &&\n        id === \"lastColour\" &&\n        index < intervals.length - 1\n      ) {\n        updatedIntervals[index + 1] = {\n          ...updatedIntervals[index + 1],\n          firstColour: colour,\n        };\n      }\n      setIntervals(updatedIntervals);\n    },\n    [intervals, setIntervals]\n  );\n\n  const handleNewInterval = useCallback(() => {\n    const newIntervals = [...intervals];\n    const previousInterval = newIntervals[newIntervals.length - 1];\n\n    // Find best way to generate new colour with a good contraste to previous colour\n    const newIntervalLastColour = (colour: RgbColor) => {\n      if (newIntervals.indexOf(previousInterval) % 2 == 0) {\n        return new TinyColor(previousInterval.lastColour)\n          .tetrad()[3]\n          .darken(20);\n      }\n      return new TinyColor(previousInterval.lastColour).triad()[2].lighten(20);\n    };\n    const newInterval = {\n      ...newIntervals[0],\n      firstColour: previousInterval.lastColour,\n      lastColour: newIntervalLastColour(previousInterval.lastColour),\n    };\n\n    newIntervals.push(newInterval);\n    setIntervals(newIntervals);\n  }, [intervals, setIntervals]);\n\n  const handleDeleteInterval = (index: number) => {\n    const updatedIntervals = [...intervals];\n    updatedIntervals.splice(index, 1);\n\n    // //Makes sure new element's firstColour at index matches previous element's lastColour\n    if (0 < index && index < intervals.length - 1) {\n      updatedIntervals[index] = {\n        ...updatedIntervals[index],\n        firstColour: { ...updatedIntervals[index - 1].lastColour },\n      };\n    }\n    setIntervals(updatedIntervals);\n  };\n\n  return (\n    <form action=\"\" onSubmit={start}>\n      <h1>Colour Timer</h1>\n\n      {intervals.map((interval, index) => (\n        <Interval\n          key={index}\n          index={index}\n          firstColour={interval.firstColour}\n          lastColour={interval.lastColour}\n          onDurationChange={handleDurationChange}\n          onColourChange={handleColourChange}\n          onDelete={handleDeleteInterval}\n          showDeleteButton={intervals.length > 1}\n        />\n      ))}\n      <button type=\"button\" onClick={handleNewInterval}>\n        Add interval\n      </button>\n\n      <button type=\"submit\">Start !</button>\n    </form>\n  );\n}\n\nexport default Form;\n","import React, { useState, useCallback, FormEvent } from \"react\";\nimport { RgbColor } from \"react-colorful\";\nimport \"./App.css\";\nimport Form from \"./Form/Form\";\nimport { formatToRGBString } from \"./util\";\n\nexport type TInterval = {\n  firstColour: RgbColor;\n  lastColour: RgbColor;\n  duration: number;\n};\n\nconst defaultIntervals = [\n  {\n    firstColour: { r: 24, g: 31, b: 47 },\n    lastColour: { r: 70, g: 187, b: 226 },\n    duration: 0,\n  },\n];\n\nfunction App() {\n  const [isActive, setIsActive] = useState(false);\n\n  const [intervals, setIntervals] = useState<TInterval[]>(defaultIntervals);\n\n  const [startDate, setStartDate] = useState<Date>();\n  const [currentDate, setCurrentDate] = useState<Date>();\n  const [totalDuration, setTotalDuration] = useState<number>(0);\n  const [index, setIndex] = useState<number>(0); // Remove 0?\n\n  let currentColour = intervals[0].firstColour;\n\n  const timer = useCallback(\n    async (interval: TInterval, i: number) => {\n      return new Promise<void>((resolve, reject) => {\n        const updatedStartDate = new Date();\n        setStartDate(updatedStartDate);\n\n        // To do: Save intervalID outside callback so it can be used to pause or clear timer. const intervalID = useRef\n        const intervalID = setInterval(() => {\n          const updatedCurrentDate = new Date();\n          if (\n            updatedCurrentDate.getTime() >=\n            updatedStartDate.getTime() + interval.duration\n          ) {\n            if (i === intervals.length - 1) {\n              setIsActive(false);\n              setStartDate(undefined);\n              setCurrentDate(undefined);\n            }\n            resolve();\n            clearInterval(intervalID);\n          }\n          setCurrentDate(updatedCurrentDate);\n        }, interval.duration / 256);\n      });\n    },\n    [intervals.length]\n  );\n\n  const loopThroughEachInterval = useCallback(async () => {\n    for (let i = 0; i < intervals.length; i++) {\n      let interval = intervals[i];\n\n      setIndex(i);\n      await timer(interval, i);\n    }\n  }, [timer, intervals]);\n\n  const start = useCallback(\n    (event: FormEvent) => {\n      event.preventDefault();\n      try {\n        if (totalDuration === 0) throw new Error(\"Duration = 0\");\n        // intervals.every\n      } catch (err) {\n        console.error(err.message);\n        return false;\n      }\n      setIsActive(true);\n      loopThroughEachInterval();\n    },\n    [totalDuration, loopThroughEachInterval]\n  );\n\n  if (currentDate && startDate) {\n    const timeSpentRatio =\n      (currentDate.getTime() - startDate.getTime()) / intervals[index].duration;\n\n    const changeAmount = {\n      r: Math.round(\n        (intervals[index].lastColour.r - intervals[index].firstColour.r) *\n          timeSpentRatio\n      ),\n      g: Math.round(\n        (intervals[index].lastColour.g - intervals[index].firstColour.g) *\n          timeSpentRatio\n      ),\n      b: Math.round(\n        (intervals[index].lastColour.b - intervals[index].firstColour.b) *\n          timeSpentRatio\n      ),\n    };\n    // Note: variations can be negative numbers\n    // /!\\ changeAmount need to be integers /!\\\n\n    currentColour = {\n      r: intervals[index].firstColour.r + changeAmount.r,\n      g: intervals[index].firstColour.g + changeAmount.g,\n      b: intervals[index].firstColour.b + changeAmount.b,\n    };\n  }\n\n  return (\n    <div\n      className=\"App\"\n      style={{\n        backgroundColor: formatToRGBString(currentColour),\n      }}\n    >\n      {!isActive && (\n        <Form\n          start={start}\n          intervals={intervals}\n          setIntervals={setIntervals}\n          setTotalDuration={setTotalDuration}\n        />\n      )}\n      {isActive &&\n        intervals.map((interval, index) => (\n          <div\n            className=\"firstToLastColourCircle\"\n            key={index}\n            style={{\n              backgroundImage: `linear-gradient(to right, ${formatToRGBString(\n                interval.firstColour\n              )}, ${formatToRGBString(interval.lastColour)})`,\n              // backgroundColor:  formatToRGBString(intervals[index].lastColour),\n            }}\n          ></div>\n        ))}\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\ntype Config = {\n  onSuccess?: (registration: ServiceWorkerRegistration) => void;\n  onUpdate?: (registration: ServiceWorkerRegistration) => void;\n};\n\nexport function register(config?: Config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(\n      process.env.PUBLIC_URL,\n      window.location.href\n    );\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl: string, config?: Config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl: string, config?: Config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}